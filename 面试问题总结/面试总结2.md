# 面试总结

**cdn下载监控显示request time突曾，可能是源站返回了下面哪个状态码？**

A 502

B 503

C 504

D 429



CDN作用：

​	1.实现跨运营商、跨地域的全网覆盖

 2. 为了保护网站的安全

     1. > CDN的负载均衡和分布式存储技术,可以加强网站的可靠性,相当于一把无形中的保护伞,应对绝大多数的互联网攻击事件,防攻击系统也能避免网站遭到恶意攻击.

 3. 可以做异地灾备

     1. > 当服务器发生故障的时候,系统将会调用其他的临近的健康服务节点进行服务,进而提供近乎100%的可靠性,保证站点永不宕机

 4. 节约成本投入

     1. >  使用CDN加速可以实现网站的全国铺设，你根据不用考虑购买服务器与后续的托管运维，服务器之间镜像同步，也不用为了管理维护技术人员而烦恼，节省了人力、精力和财力。

 5. 为了让你更专注业务本身

    **主要特点**

    1. 本地Cache加速，提高了企业站点（尤其含有大量图片和静态页面站点）的访问速度，并大大提高以上性质站点的稳定性
    2. 镜像服务消除了不同运营商之间互联的瓶颈造成的影响，实现了跨运营商的网络加速，保证不同网络中的用户都能得到良好的访问质量。
    3. 远程加速 远程访问用户根据DNS负载均衡技术 智能自动选择Cache服务器，选择最快的Cache服务器，加快远程访问的速度
    4. 带宽优化 自动生成服务器的远程Mirror（镜像）cache服务器，远程用户访问时从cache服务器上读取数据，减少远程访问的带宽、分担网络流量、减轻原站点WEB服务器负载等功能。
    5. 集群抗攻击 广泛分布的CDN节点加上节点之间的智能冗余机制，可以有效地预防黑客入侵以及降低各种D.D.o.S攻击对网站的影响，同时保证较好的服务质量 。

    **CDN给谁加速**

    1. 直接对单个三级域名进行加速

    **优势是啥**

    1. 保证节点的可用性,当节点不可用的时候会剔除.
    2. 部署简单,不影响原站点

    **CDN和机房双线的区别**

    1. 双线机房只能解决电信联通之间的延迟问题,对其他延迟没有实质的解决
    2. CDN可以保证访问者访问的是最快的最稳定的

    **CDN缓存问题解决办法**

    1. CDN管理面板提供了URL推送服务,来通知各个节点刷新自己的缓存
    2. 各个节点收到推送后,会删除本地缓存
    3. 推送的太多可以选择目录推送

    **网站新增页面和站点不需要URL推送**

    **不适合的群体**

    1. 适度的用户群  
       * 针对性, 特定性
       * 服务少数用户
    2. 极端本地化用户群
       * 给定地理区域
       * 本地化
    3.  监管和复杂的之力要求
       * 用户数据敏感
       * 数据管辖范围权限

    6. **访问出现412**

    > 可能是网站做了鉴权,同时存在很多的盗链,因此有412

    **返回状态504**

    > 表示三次握手失败,网关超时

    **502**

    > 三次握手成功,但是首包超时,或者客户端read payload 超时.

    **500**

    > 代表服务端应用不可用

    **503**

    > 服务器当前无法处理请求,一段时间后会自动恢复.

    **428 Precondition Requeired(要求先决条件)**

    > 先决条件是客户端发送 HTTP 请求时，必须要满足的一些预设条件。一个好的例子就是 If-None-Match 头，经常用在 GET 请求中。如果指定了 If-None-Match ，那么客户端只在响应中的 ETag 改变后才会重新接收回应。
    >
    > 先决条件的另外一个例子是 If-Match 头，一般用在 PUT 请求上，用于指示只更新但没有被改变的资源。这在多个客户端使用 HTTP 服务时用来防止彼此间覆盖相同内容的情况。
    >
    > 当服务器端使用 [428 Precondition Required 状态码](http://tools.ietf.org/html/rfc6585#section-3)时，表示客户端必须发送上述的请求头才能执行该请求操作。这个方法为服务器提供一种有效的方法来阻止 “lost update”问题的出现。

    **429 Too Many Rquests (太多请求)**

    > 当你需要限制客户端请求某个服务的数量，也就是限制请求速度时，该状态码就会非常有用。在此之前，有一些类似的状态码。例如“509 Bandwidth Limit Exceeded”。
    >
    >如果你希望限制客户端对服务的请求数，可使用 429 状态码，同时包含一个 Retry-After 响应头用于告诉客户端多长时间后可以再次请求服务。
    >
    >

[地址是](<https://www.cnblogs.com/gisblogs/p/7121943.html>)



    requesr_ time
    
    * 指的是从接收用户请求的第一个字到发送完响应数据的时间,即包括接收请求的数据时间、程序响应时间、输出响应时间。
    
    **upstream_response_time**
    
    * 是指从nginx向后端(php-cgi)建立连接开始到接受完整数据然后关闭连接为止的时间.
    
    从上面的描述可以看出，$request_time肯定比$upstream_response_time值大，特别是使用POST方式传递参数时，因为Nginx会把request body缓存住，接受完毕后才会把数据一起发给后端。所以如果用户网络较差，或者传递数据较大时，$request_time会比$upstream_response_time大很多。
    
    所以如果使用nginx的accesslog查看php程序中哪些接口比较慢的话，记得在log_format中加入$upstream_response_time。

![avatar](../images/20200423091527.png)

![avatar](../images/20200423092016.png)

![avatar](../images/20200423092213.png)



![avatar](../images/20200423092350.png)



![avatar](../images/20200423092654.png)



![avatar](../images/20200423092724.png)

![avatar](../images/20200423092750.png)



![avatar](../images/20200423092824.png)



![avatar](../images/20200423092849.png)



![avatar](../images/20200423092917.png)

![avatar](../images/20200423092946.png)



![avatar](../images/20200423093007.png)



![avatar](../images/20200423093037.png)



![avatar](../images/20200423093103.png)



![avatar](../images/20200423093438.png)





![avatar](../images/20200423093508.png)



![avatar](../images/20200423093534.png)



![avatar](../images/20200423093601.png)

![avatar](../images/20200423093635.png)

![avatar](../images/20200423093659.png)

![avatar](../images/20200423093817.png)



![avatar](../images/20200423093844.png)

![avatar](../images/20200423093912.png)

![avatar](../images/20200423093941.png)

![avatar](../images/20200423094007.png)

![avatar](../images/20200423094040.png)



